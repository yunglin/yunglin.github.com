<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mongodb | 碎碎唸]]></title>
  <link href="http://blog.yunglinho.com/blog/categories/mongodb/atom.xml" rel="self"/>
  <link href="http://blog.yunglinho.com/"/>
  <updated>2014-02-12T14:53:47+08:00</updated>
  <id>http://blog.yunglinho.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mongodb Scala DAO]]></title>
    <link href="http://blog.yunglinho.com/blog/2012/04/30/mongodb-dao/"/>
    <updated>2012-04-30T11:50:00+08:00</updated>
    <id>http://blog.yunglinho.com/blog/2012/04/30/mongodb-dao</id>
    <content type="html"><![CDATA[<p>這篇文章將說說，我使用 MongoDB &amp; Cashbah 的一些心得，這程式的主架構是
我從 simplistic_ 學來的。</p>

<p>.. _simplistic: https://github.com/aboisvert/simplistic</p>

<h1>The Abstract DAO</h1>

<p>底下是一個很簡單的 CRUD 的 MongoDB DAO. 在這邊，我們建立一個 DAO 時，我們會把這
個 DAO 用的儲存空間 MongoCollection 傳進來，另外要注意的一點是，這個 MongoCollection 的
WriteConcert 必需是 Strict 的。</p>

<p>.. code-block:: scala</p>

<p>  /<em>*
   *  Base class for all DAO classes.
   </em>/
  abstract class AbstractDAO<a href="protected[locadz]%20val%20mongoCol:%20MongoCollection">T, ID &lt;: Serializable</a> {</p>

<pre><code>/** builder to turn mongodb object into model object */
implicit protected val builder: DBObject =&gt; Either[DataAccessException, T]

/** builder to turn model object into mongodb object */
implicit protected val extractor: T =&gt; DBObject

/** this dao expects the underlying mongoCol would throw exception when error occurs. */
require(mongoCol.getWriteConcern != null)
require(mongoCol.getWriteConcern.getW &gt;= 1, "Write must be &gt;= 1, was %d".format(mongoCol.getWriteConcern.getW))

/** insert object into the underly*/
def insert(obj: T): Either[DataAccessException, ID] = {
  try {
    val dbObj: DBObject = extractor(obj)
    val res: WriteResult = mongoCol.insert(dbObj)
    Right(dbObj.getAs[ID]("_id").get)
  } catch {
    case e: MongoException      =&gt; Left(new DataAccessException(e))
    case e: DataAccessException =&gt; Left(e)
  }
}

def save(obj: T): Option[DataAccessException] = {
  try {
    val res = mongoCol.save[T](obj)
    None
  } catch {
    case e: MongoException      =&gt; Some(new DataAccessException(e))
    case e: DataAccessException =&gt; Some(e)
  }
}

def findById(id: ID): Either[DataAccessException, Option[T]] = {
  try {
    mongoCol.findOneByID(id) match {
      case None        =&gt; Right(None)
      case Some(dbObj) =&gt; builder.apply(dbObj).right.map(Option(_))
    }
  } catch {
    case e: DataAccessException =&gt; Left(e)
  }
}

def delete(id: ID): Option[DataAccessException] = {
  try {
    mongoCol.remove(MongoDBObject("_id" -&gt; id))
    None
  } catch {
    case e: MongoException =&gt; Some(new DataAccessException(e))
  }
}

def find[T](dbObj: DBObject)(implicit builder: (DBObject) =&gt; Either[DataAccessException, T]): Either[DataAccessException, Iterable[T]] = {

  try {
    Right(mongoCol.find(dbObj)
      .flatMap(found =&gt; {
        builder.apply(found).fold(
          e =&gt; throw e,
          r =&gt; Some(r))
      }).toStream)

  } catch {
    case e: DataAccessException =&gt; Left(e)
  }
}
</code></pre>

<p>  }</p>

<p>這邊有兩個需要被實作的東西</p>

<ul>
<li><code>val builder: DBObject =&gt; Either[DataAccessException, T]</code></li>
<li><code>val extractor: T =&gt; DBObject</code></li>
</ul>


<p>而怎麼建立這兩個東西，就是全文的重點了。</p>

<h1>How to use AbstractDAO</h1>

<p>先來看一個範例；實作上，在 UserDAO object 上，我們先把欄位的名稱及資料型態，一個個的定好</p>

<ul>
<li>'val Name = attribute("name", Conversion.String)`</li>
<li>'val Email = attribute("email", Conversion.String)'</li>
<li>'val CreateDate = attribute("ctime", Conversion.JodaDate)'</li>
</ul>


<p>而這個 attribute method 做的是，把資料名稱存起來，然後當這個 Attribute instance</p>

<ul>
<li>收到一個 DBObject 時，把對應的欄位取出來，並將值給轉成定義的格式</li>
<li>收到一個 property value 時，把他轉成 (name -> value) pair</li>
</ul>


<p>第一個用法的這個方式，用在從 <em>builder</em> 上面，一個個的把值從 DBObject 抓出來再來建立物件，
第二個用法用在，把物件轉成 DBObject 時，及用在建立 query 時。</p>

<h2>UserDAO 實作</h2>

<p>.. code-block:: scala</p>

<p>  class UserDAO(mongoCol: MongoCollection) extends AbstractDAO<a href="mongoCol">User, String</a> {</p>

<pre><code>import UserDAO._

implicit protected val builder: (DBObject) =&gt; Either[DataAccessException, User] = UserDAO.dbObjectToUser _

implicit protected val extractor: (User) =&gt; DBObject = UserDAO.userToDBObject _

def this(dbCol: DBCollection) = this(dbCol.asScala)
</code></pre>

<p>  }</p>

<p>  object UserDAO {</p>

<pre><code>import Attributes._

val Name = attribute("name", Conversion.String)

val Email = attribute("email", Conversion.String)

val CreateDate = attribute("ctime", Conversion.JodaDate)

def dbObjectToUser(dbObj: DBObject): Either[DataAccessException, User] = {

  try {
    val id = dbObj.getAs[String]("_id").get

    Right(
      new User(id,
        Name(dbObj),
        Email(dbObj),
        CreateDate(dbObj)
      )
    )
  } catch {
    case e: DataAccessException =&gt; Left(e)
  }
}

implicit def userToDBObject(user: User): DBObject = {

  val ret = MongoDBObject("_id" -&gt; user.id)
  ret += Name(user.externalId)
  ret += Email(user.verifiedId)
  ret += CreateDate(user.createDate)
  return ret
}
</code></pre>

<p>  }</p>

<h2>Attribute &amp; Conversion 部份實作</h2>

<p>.. code-block:: scala</p>

<p>  trait Attribute[A, B &lt;: Any] {</p>

<pre><code>val name: String
val conversion: Conversion[A, B]

protected implicit val manifestA: Manifest[A]
protected implicit val manifestB: Manifest[B]
</code></pre>

<p>  }</p>

<p>  trait RequiredAttribute[A, B &lt;: Any] extends Attribute[A, B] {</p>

<pre><code>def apply(value: A): Tuple2[String, B] = {
  name -&gt; conversion.apply(value)
}

def apply(value: DBObject): A = {
  value.getAs[B](name).map(b =&gt; conversion.unapply(b)).getOrElse(throw new MissingRequiredAttributeException(name))
}
</code></pre>

<p>  }</p>

<p>  def attribute<a href="name:%20String,%20dataType:%20Conversion[A,%20B]">A, B &lt;: Any</a>(implicit manifestA: Manifest[A], manifestB: Manifest[B]) = {</p>

<pre><code>new SingleValueRequiredAttribute[A, B](name, dataType)
</code></pre>

<p>  }</p>

<p>  trait Conversion[A, B] {</p>

<pre><code>def apply(source: A): B
def unapply(value: B): A
</code></pre>

<p>  }</p>

<p>  object Conversion {</p>

<pre><code>case object String extends Conversion[String, String] {
  override def apply(source: String) = source
  override def unapply(value: String) = value
}

/**
 * Conversion for DateTime to DateTime.
 */
object JodaDate extends Conversion[DateTime, DateTime] {

  RegisterJodaTimeConversionHelpers()

  override def apply(source: DateTime): DateTime = source
  override def unapply(value: DateTime): DateTime = value
}
</code></pre>

<p>  }</p>

<h1>How to Use Attributes to Build Query</h1>

<p>前面的 Attribute(s) 不只是用來產做 builder 及 extractor 用的，他們最好用的地方在於
建立 query 時，如下</p>

<p>.. code-block:: scala</p>

<p>  def findByDateRange(start: DateTime, end: DateTime): Either[DataAccessException, User] = {</p>

<pre><code>return find(CreateDate.name $gth CreateDate(start)._2  $lt CreateDate(range)._2)
</code></pre>

<p>  }</p>

<p>這邊，我們可以看到用 Conversion 來描述資料型態的好處是，當你儲存的資料型態有變時，你不用去更
改你的 MongoDB query ，欄位的名稱、資料型別的轉換，都被封裝起來，使用者在寫 Query 時，不用去
記欄位的名稱，也不用去記這個欄位的型態是什麼， MongoDB 支不支援這個型態。</p>

<p>第二個好處是， Casbah 本來只支援 java primitive type &amp; java.util.Date ，透過 Conversion ，
我們可以支援任意的資料型態於 query 中，只要透過新的 Conversion 類別，我們就可以增加 MongoDB 可以
支援的資料型態。</p>

<p>例如，如果我們想增加對 <code>java.net.URL</code> 的支援，只要訂義以下的 Conversion 即可</p>

<p>.. code-block:: scala</p>

<p>  case object Url extends Conversion[URL, String] {</p>

<pre><code>override def apply(source: URL) = source.toExternalForm

override def unapply(value: String) = new URL(value)
</code></pre>

<p>  }</p>

<h1>Appendix:</h1>

<h2>Attribute.scala</h2>

<p>.. code-block:: scala</p>

<p>  package com.locadz.model.mongodb</p>

<p>  import com.mongodb.DBObject
  import com.mongodb.casbah._
  import com.locadz.model.exception.MissingRequiredAttributeException</p>

<p>  /<em>*
   * Date: 2/20/12
   </em>/
  object Attributes {</p>

<pre><code>trait Attribute[A, B &lt;: Any] {
  val name: String
  val conversion: Conversion[A, B]

  protected implicit val manifestA: Manifest[A]

  protected implicit val manifestB: Manifest[B]

}

trait OptionalAttribute[A, B &lt;: Any] extends Attribute[A, B] {

  def apply(value: Option[A]): Tuple2[String, Any] = {
    val v = value.map(conversion.apply(_)).getOrElse(null)
    name -&gt; v
  }

  def apply(value: DBObject): Option[A] = value.getAs[B](name).map(b =&gt; conversion.unapply(b))

}

trait RequiredAttribute[A, B &lt;: Any] extends Attribute[A, B] {

  def apply(value: A): Tuple2[String, B] = {
    name -&gt; conversion.apply(value)
  }

  def apply(value: DBObject): A = {
    value.getAs[B](name).map(b =&gt; conversion.unapply(b)).getOrElse(throw new MissingRequiredAttributeException(name))
  }
}

case class SingleValueRequiredAttribute[A, B &lt;: Any](name: String, conversion: Conversion[A, B])(implicit val manifestA: Manifest[A], implicit val manifestB: Manifest[B]) extends RequiredAttribute[A, B]

case class SingleValueOptionalAttribute[A, B &lt;: Any](name: String, conversion: Conversion[A, B])(implicit val manifestA: Manifest[A], implicit val manifestB: Manifest[B])
  extends OptionalAttribute[A, B]

def attribute[A, B &lt;: Any](name: String, dataType: Conversion[A, B])(implicit manifestA: Manifest[A], manifestB: Manifest[B]) = {
  new SingleValueRequiredAttribute[A, B](name, dataType)
}

def optionalAttribute[A, B &lt;: Any](name: String, dataType: Conversion[A, B])(implicit manifestA: Manifest[A], manifestB: Manifest[B]) = {
  new SingleValueOptionalAttribute[A, B](name, dataType)
}
</code></pre>

<p>  }</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Problem in Mongodb's java and scala driver.]]></title>
    <link href="http://blog.yunglinho.com/blog/2012/04/26/mongodb-java-driver-sucks/"/>
    <updated>2012-04-26T18:45:00+08:00</updated>
    <id>http://blog.yunglinho.com/blog/2012/04/26/mongodb-java-driver-sucks</id>
    <content type="html"><![CDATA[<p>MongoDB 的 Java Driver 支援透過 Transformer<em> 去掛上 encodingHook 及 decodingHook，
使用方式可以參考 <code>Salat URISerializer</code></em>.</p>

<p>原本我以為透過這樣，我就可以透過自定 encoding and decoding Hook ，去動態
的把 MongoDB 內部的資料型態，在抓取時，自動轉成我要的形態。</p>

<p>例如透過底下的程式碼，就在呼叫 <code>getAs[URL]("url")</code>_ 時，才即時的把 String 轉成 URL 。</p>

<p>.. code-block:: scala</p>

<p>  BSON.addEncodingHook(class[URL], new Transformer {</p>

<pre><code>def transform(o: AnyRef): AnyRef = o match {
  case u: URL =&gt; u.toExternalForm 
  case _      =&gt; o
}
</code></pre>

<p>  })
  BSON.addDecodingHook(class[URL], new Transformer {</p>

<pre><code>def transform(o: AnyRef): AnyRef = o match {
  case s:String =&gt; new URL(s)
  case _ =&gt; throw new IllegalArgumentException(o.toString)
}
</code></pre>

<p>  })</p>

<p>結果，事情不如我預期所想的， <code>decodingHook</code> 是掛在 MongoDB 儲存的資料
型態上，而不是你所需要的資料型態上；換個方法講， <code>decodingHook</code> 是在
BSON driver 把資料讀出來時，就呼叫的。</p>

<p>實作上，如果你去細看 Salat URISerializer ，他的 <code>decodingHook</code> 是註冊
在 <code>String Type</code> 而非 <code>URI Type</code> ，而實作時，是把字串加上了 "<code>URI~</code>" 來
判斷，這個字串是否是該被 URI Serializer 轉型成 URI。</p>

<p>如果你去看 <code>org.bson.BSON</code> 的實作，你會看到底下這段恐怖的程式碼，BSON
在讀出資料時，會把對該型別的 <code>Transformer</code> 全跑一遍，而這個東西又是個
Gloabal Variable，這樣一來出了三個問題</p>

<ul>
<li><p>所有 Custom Data Type 都需要被轉成 String 並加上 Prefix 才可以寫入，
你不可以把一個 Custom Data Type 轉成 Integer ，如果你這麼做了，所有
的 Integer ，包含本來就該是 Integer 的欄位，未來在讀出來時，全都會變成
這個 Custom Data Type ！</p></li>
<li><p>你的 MongoDB Driver 仰賴所有的使用者都清楚他在做什麼，也清楚別人在
做什麼，如果有一個 Transformer 出錯了，或者是 Prefix 重覆了，那麼
你自定的 Custom Data Type 也會出錯。</p></li>
<li><p>你 MongoDB 中的資料，為了儲存 Data Type 於資料欄位中而被污染了！</p></li>
</ul>


<p>.. code-block:: java</p>

<pre><code>public static void addDecodingHook( Class c , Transformer t ){
    _decodeHooks = true;
    List&lt;Transformer&gt; l = _decodingHooks.get( c );
    if ( l == null ){
        l = new Vector&lt;Transformer&gt;();
        _decodingHooks.put( c , l );
    }
    l.add( t );
}

public static Object applyDecodingHooks( Object o ){
    if ( ! _anyHooks() || o == null )
        return o;

    List&lt;Transformer&gt; l = _decodingHooks.get( o.getClass() );
    if ( l != null )
        for ( Transformer t : l )
            o = t.transform( o );
    return o;
}
</code></pre>

<p>SCALA-66_ 說 3.0.0 release 時，會有一個 per field, per data type 的
type conversion機制，不過 3.0.0-M2 時還沒把這塊做進去，所以看來有得等了</p>

<p>我是自己有參照 simplistic_ 刻一個機制，可以在 DAO 中讀進讀出物件時做轉
換，但是在寫 Query 時，仍是有些不便。</p>

<p>如果你有這需求的話，可以跟我連絡，我把 source code 給你。</p>

<p>.. _Transformer: http://api.mongodb.org/java/2.5/org/bson/Transformer.html</p>

<p>.. _Salat URISerializer: https://github.com/novus/salat/blob/9d7988fbd212b6a1423cb2be72065ebff3570777/salat-core/src/test/scala/com/novus/salat/test/util/UriConversionHelper.scala</p>

<p>.. _getAs<a href="" title="url">URL</a>: http://api.mongodb.org/scala/casbah/2.1.5.0/scaladoc/com/mongodb/casbah/commons/MongoDBObject.html#getAs<a href="String">A</a>(Manifest[A]):Option[A]</p>

<p>.. _SCALA-66: https://jira.mongodb.org/browse/SCALA-66</p>

<p>.. _simplistic: https://github.com/aboisvert/simplistic</p>
]]></content>
  </entry>
  
</feed>
